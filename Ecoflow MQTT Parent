/***
 *                                                                  
 *                                PARENT DRIVER ECOFLOW MQTT BROKER FOR HUBITAT          
 *
 *    The driver will create child devices for each EF device added. The Delta2: AC, DC, & USB. The Delta Pro: AC & DC. The River
 *   AC, DC, and LED light.
 *
 *    DRIVER USE - Use this driver in the background as its use is not sanctioned by Ecoflow
 *               Do not share the link to this driver on general forums
 *               Do not share dashboards and driver details to EF forums or FB group pages
 *               You may share the driver link with other Hubitat/Ecoflow users but do so off open forums.
 *               The more EF knows about these backdoor drivers, the shorter their life cycle.
 *              
 *
 *
 *  
 *
 *************************************** Special Instructions for Broker Account ************************************************
 *  A procedure is required to obtain your MQTT access keys. See GitHub folder for MQTT key instructions to obtain your MQTT    *
 *  keys. Or follow this link to grab the instructions:                                                                         *
 *  https://github.com/darryl678/darryl678/blob/Hubitat-EF-Delta-Driver/Accessing-EF-.docx                                      *
 ********************************************************************************************************************************           
 *                                                                                                                              *
 **************************************** Special Instructions for Adding Devices ***********************************************
 *       The Ecoflow Broker will not distrubute devices serial numbers so child devices can not be auto generated by the        *
 *       parent driver. Follow this instructions for adding EF batteries. Make sure the child driver code is saved into Hubitat *  
 *          1. In parent driver - Add broker account information and per the instructions above - get the broker online         *
 *          2. Enter a friendly name for your drive - ex home, cabin, Sparky - Click To Enter the Value                         *
 *          3. Enter the Device's serial number - Click to enter the value                                                      * 
 *          4. Enter the device model number - no caps - no spaces - river - deltapro - delta2 - Click to Enter value           *
 *          5. Click Add New Device                                                                                             *
 *          6  A child device will be created called "freindly name" "serial number" "model"                                    *
 *          7  Create as many child devices as you have EF units.                                                               *
 *          8. Open each child device and initalize the driver.                                                                 *     
 ********************************************************************************************************************************
 *
 *     To delete a child device - click "confirm delete devcie" to turn on delete modde - active for 60 seconds
 *                              - Enter the serial number (serial only) of the child to delete and click the tab
 *
 *     To delete all child devices - click "confirm delete devcie" to turn on delete modde - active for 60 seconds
 *                                   click Delete All Child Devices 
 *
 *     Due to a hubitat limitation nested child devices are not show in the UI - go the the bottom of the device screen
 *     to view the componentchild contol devcies for each EF child device - the AC switch, DC switch, ect. 
 *  
 *  Thank You(s)
 *  Mark H. - for helping me get mqtt explorer connected to my battery. That was the starting point.
 *  @shircliffs for giving me control of his Delta Pro to test functions and figure out variable names
 *  @steve101 for providing Delta Pro model parameters
 *  @ronv42 for providing River Parameters and driver path discussions
 *  @snell for always taking the time to give detailed responses to my never-ending coding questions.
 *
 * ------------------------------------------------------------------------------------------------------------------------------
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *
 *
 *  Changes: 3-17-23   beta - limited release
 *                	
 *
 */
 


import groovy.json.JsonSlurper;

metadata {
  definition(name: "Ecoflow MQTT Parent", namespace: "Ecoflow", author: "Darryl Dimond", importURL: "not listed") {
    capability "Initialize"
    capability "Actuator"
    command "Disconnect"
    command "AddNewDevice"
    command "DeleteDevice",["string"]
    command "DeleteAllChildDevices"
    command "ConfirmDeviceDelete"
    command "DeviceModel",["string"]
    command "DeviceFriendlyName",["string"]  
    command "DeviceSerialNumber",["string"]
    command  "ManualRefreshData"
    
    attribute  "mqtt Status", "number"
    
    }

  preferences {
    input name: "mqttclientname", type: "text", title: "mqttclientname:", required: true, displayDuringSetup: true
    input name: "MQTTBroker", type: "text", title: "MQTT Broker Address:", required: true, displayDuringSetup: true, defaultValue: "mqtt.ecoflow.com"
    input name: "username", type: "text", title: "MQTT Username:", description: "(blank if none)", required: false, displayDuringSetup: true
    input name: "password", type: "password", title: "MQTT Password:", description: "(blank if none)", required: false, displayDuringSetup: true
    input name: "guid", type: "text", title, " guid", description: "random 9 digit device code - differnet # then other EF devices using your MQTT account", required: true
    input("logEnable", "bool", title: "Enable logging", required: true, defaultValue: true)
  }
}

def installed() {
  initialize()
}

def DeviceModel(model) {
    state.UnitModel = model
    log.info state.UnitModel
    if (model == null) log.info"Model of device must defined as parameter"
}

def DeviceFriendlyName(friend) {
    log.info friend
    state.FriendName = friend
    if (friend == null) log.info"freindly name not defined - device name set a serial number + model"
}

def DeviceSerialNumber(serial) {
    log.info serial
    state.UnitSerial = serial
    if (serial != null) state.model = state.serial
    if (serial == null) log.info "Serial number of device must defined as parameter"
}

def AddNewDevice() {
  log.info "add new device " + state.FriendName + " " + state.UnitSerial  + " " + state.UnitModel 
  if (state.UnitSerial != null && state.FriendName != null &&state.UnitModel != null ) {
    switch (state.UnitModel) {
    case "delta2": 
      cdriver = "EcoFlow Battery mqtt CHILD"
    break  
    case "river":
      cdriver = "EcoFlow Battery mqtt CHILD"
    break
    case "shp":
      cdriver = "EcoFlow SHP mqtt"
    break  
    case "deltapro":
      cdriver = "EcoFlow Battery mqtt CHILD"
    break  
      default:
      cdriver = null
      log.info "device model not found " + state.UnitModel + " check spelling - no caps"
    }
    def cd = getChildDevice(state.UnitSerial)
    if (cd == null) {                                                                                                                                                                
      log.info "creating child"  
        addChildDevice( "${cdriver}", "${state.UnitSerial}", [ name: "${state.FriendName} ${state.UnitSerial} ${state.UnitModel}" ] )
      state.UnitSerial = null                                        
      }else{ 
        log.info "Existing Device Found With Same Serial Number!" 
      }
  }else{  
    log.info "unit serial number and model can not be blank"   
  }
}

def DeleteAllChildDevices() {
  if ( state.ConfrimDelete == 1) {
    log.info "Uninstalling all Child Devices"
    getChildDevices().each {
      deleteChildDevice(it.deviceNetworkId)
    }
    state.ConfrimDelete = 0
  }else{
    log.info "set confirm child delete mode before deleting device(s)"   
  }
}
    

def ConfirmDeviceDelete(){
  state.ConfrimDelete = 1
  runIn (60 , deletemodeoff)
}

def deletemodeoff () {
     state.ConfrimDelete = 0
}

def DeleteDevice (serial) {
   def cd = getChildDevice(serial)
   if (cd == null) {                                                                                                                                                                
     log.info "Device not found - check serial number"  
   }else{
     if ( state.ConfrimDelete == 1) {
       deleteChildDevice(serial)
       log.info "Device ${serial} has been deleted" 
       state.ConfrimDelete = 0 
     }else{  
     log.info "devcie found but not deleted - set confirm child delete mode before deleting device"   
     }
  }
}

// Parse incoming device messages to generate events
def parse(String description) {
   payload = interfaces.mqtt.parseMessage(description).payload
   if (payload != null) {
     //log.info payload  
     def jsonSlurper = new JsonSlurper()
     def jsonpl = jsonSlurper.parseText(payload)
     if (logEnable) log.debug "payload=" + payload
     def jsonObject = new JsonSlurper().parseText(payload)
     state.deviceID = jsonpl.data.sn
     if (state.deviceID != null ) {
       log.info "sending data to device ${ jsonpl.data.sn }"
       getChildDevice( "${ jsonpl.data.sn }" ).ProcessState( "mqttclientname", mqttclientname )
       getChildDevice( "${ jsonpl.data.sn }" ).ProcessJSON( payload )
     }else{
       log.info "device may be offline - no serial number retuned"
     }
   }
}

// set-up to bypass energy calculation on manual scans
def ManualRefreshData() {
  refreshdata()
            
}

//refresh data by sending mqtt command requesting data update
def refreshdata() {
  try {
    if (state.mqttOnline == 1) {
      getChildDevices().each {
        Dname = it.name
        def values = Dname.split()
        Intopic = "/app/" + mqttclientname + "/" + values[1] + "/thing/property/get_reply"
        Outtopic = "/app/" + mqttclientname + "/" + values[1] + "/thing/property/get"
        //log.info "in=" + Intopic + " out=" + Outtopic
        state.refreshpayload = /{"from":"Android","id":"380541001","moduleType":0,"operateType":"latestQuotas","params":{},"version":"1.0"}/
        interfaces.mqtt.subscribe(Intopic)
        pauseExecution(3000)
        interfaces.mqtt.publish(Outtopic, state.refreshpayload)
      }
    runIn(300, timedrefresh)
    }else{
    if (state.ManDisMQTT != 1) mqttConnect()
    }                 
  } catch (e) {
  state.mqttOnline = 0  
  log.info "Initialize error: ${e.message}"
 }
}

    
    

def timedrefresh() {
    refreshdata()
}
def publishMsg(String s) {
  //   Not a working feature
  if (logEnable) log.debug "Sent this: ${s} to ${settings?.topicPub} - QOS Value: ${settings?.QOS.toInteger()} - Retained: ${settings?.retained}"
  interfaces.mqtt.publish(settings?.topicPub, s, settings?.QOS.toInteger(), settings?.retained)
}

def updated() {
  log.info "update running"
  if (logEnable) log.info "Updated..."
  initialize()
}

def Disconnect() {
  log.info "Disconnecting from mqtt"
  interfaces.mqtt.disconnect()
  state.ManDisMQTT = 1 
  MQTTstatus = "OFFLINE" 
  sendEvent(name: "mqtt Status", value: "0", isStateChanged: true)
  getChildDevices().each {
    Dname = it.name
    def values = Dname.split()
      log.info "child MQTT OFFLINE " + values[1]   
    getChildDevice( "${ values[1] }" ).ProcessState(   "mqtt Status", MQTTstatus )
    getChildDevice( "${ values[1] }" ).ProcessEvent(   "mqtt Status", MQTTstatus, null, true ) 
    getChildDevice( "${ values[1] }" ).sendEvent(name: "mqtt Status", value: MQTTstatus, isStateChanged: true)
  }
   log.info "MQTT disconnected"
}

def initialize() {
  if (logEnable) log.info "initialize"
  if (logEnable) runIn(900, logsOff)
  if (settings.updateTime < 15) {
    state.SetUpdateTime = 15
  } else {
    state.SetUpdateTime = settings.updateTime
  }
  state.reloadData = 0
  state.reload = settings.allrefresh
  state.tbs = "00:00"
  state.firstrun = 0
  log.info "reset initialize flag=" + state.reloadData
  mqttConnect()
  refreshdata()
}

//set up mqtt server connection

def mqttConnect() {
  try {
    if (settings?.retained == null) settings?.retained = false
    if (settings?.QOS == null) setting?.QOS = "0"
    //open connection
    mqttbroker = "ssl://" + settings?.MQTTBroker + ":8883"
    settings?.topicSub = "/app/" + mqttclientname + "/" + unitserialno + "/thing/property/get_reply"
    if (logEnable) log.info "broker " + mqttbroker
    if (logEnable) log.info "client " + mqttclientname
    if (logEnable) log.info "username   " + username
    if (logEnable) log.info "password " + password
    client = "ANDROID_UUID.${guid}_${mqttclientname}"
    //log.info "ANDROID_UUID.${guid}_${mqttclientname}"
    interfaces.mqtt.connect(mqttbroker,
      client,
      username,
      password,
      lastWillQos: 0,
      lastWillMessage: "offline",
      lastWillRetain: true,
      tlsVersion: 1.2)
    if (logEnable) log.info "mqtt.con" + mqttConnect
    //give it a chance to start
    pauseExecution(1000)
    //log.info "Connection established"
    if (logEnable) log.debug "Subscribed to: ${settings?.topicSub}"
    //log.info settings?.topicSub
    interfaces.mqtt.subscribe(settings?.topicSub)
    sendEvent(name: "mqtt Status", value: "1", isStateChanged: true)
    state.mqttOnline = 1
    state.retry = 10
    refreshdata()  
    } catch (e) {
      sendEvent(name: "mqtt Status", value: "0", isStateChanged: true)
      state.mqttOnline = 0      
      log.info "MQTTconnect() -reports error: ${e.message}"
      if (state.retry == null) state.retry = 10
      state.retry = state.retry - 1
      if ( state.retry > 0 ) {
        log.info "MQTT offline - ${state.retry} - 1 min reconnect attempts before duration increase"
        runIn(60, mqttConnect)  
      }else{
        log.info "MQTT offline - retry interval set to 30 min" 
        runIn(900, mqttConnect)
    }
  }
}


def mqttClientStatus(String status) {
  log.info "mqttClientStatus " + status
  if (status.contains("succeeded")) state.mqttOnline = 1
  if (!status.contains("succeeded")) {
    try {
      log.info "mqttClientStatus=" + status
      interfaces.mqtt.disconnect()
      state.mqttOnline = 0
    } catch (e) {}
    sendEvent(name: "mqtt Status", value: "0", isStateChanged: true)
    state.mqttOnline = 0  
    if (logEnable) log.debug "Broker: ${status} Will restart in 15 seconds"
    runIn(60, mqttConnect)
  }
}

def logsOff() {
  log.warn "Debug logging disabled."
  device.updateSetting("logEnable", [value: "false", type: "bool"])
}

void componentRefresh(cd) {
log.info "received refresh request from ${cd.displayName}"
refreshdata()
}



def ParentRun( ptopic, tempPayload) {
    log.info "parentRun" + ptopic + tempPayload 
    interfaces.mqtt.publish(ptopic, tempPayload)
    //pauseExecution(5000)
    //refreshdata()  
}

// Process data to check against current state value and then send an event if it has changed
// After 5 updates - update all attrubites to catch any misses - refresh count in refreshdata() block
def ProcessEvent(Variable, Value, Unit = null, ForceEvent = false) {
     Vtemp = Value
    if ((state."${ Variable }" != Vtemp) || (state.reload == 1 )) {
       state."${ Variable }" = Vtemp
      if (Unit != null) {
        sendEvent(name: "${ Variable }", value: Vtemp, unit: Unit, isStateChanged: true)
      } else {
        sendEvent(name: "${ Variable }", value: Vtemp, isStateChanged: true)
      }
   }
}




